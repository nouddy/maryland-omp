/***
 *
 *  ##     ##    ###    ########  ##    ## ##          ###    ##    ## ########  
 *  ###   ###   ## ##   ##     ##  ##  ##  ##         ## ##   ###   ## ##     ## 
 *  #### ####  ##   ##  ##     ##   ####   ##        ##   ##  ####  ## ##     ## 
 *  ## ### ## ##     ## ########     ##    ##       ##     ## ## ## ## ##     ## 
 *  ##     ## ######### ##   ##      ##    ##       ######### ##  #### ##     ## 
 *  ##     ## ##     ## ##    ##     ##    ##       ##     ## ##   ### ##     ## 
 *  ##     ## ##     ## ##     ##    ##    ######## ##     ## ##    ## ########   
 *
 *  @Author         Ogy_
 *  @Date           05th May 2023
 *  @Weburl         https://maryland-ogc.com
 *  @Project        maryland_project
 *
 *  @File           crypto_ogy.script
 *  @Module         crypto
 * 
 * CalculatorCryptoPlayer(id igraca kojem se racuna, kolicina za klk je kupio crypto, i id kripto valute(1 - btc, etc))
 */

#include <ysilib\YSI_Coding\y_hooks>


/*
     __     __                 _           _       _              
     \ \   / /   __ _   _ __  (_)   __ _  | |__   | |   ___   ___ 
      \ \ / /   / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
       \ V /   | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
        \_/     \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/

*/
new transactions,
    transactionsBTC,
    transactionsLTC,
    transactionsDOT,
    transactionsXRP,
    transactionsUSDT;

new PlayerText:BinanceTD[MAX_PLAYERS][160];

new bool:finishedyet = false;

new bool:WatchingCryptoTD[MAX_PLAYERS];

/*
      ____            __   _                      
     |  _ \    ___   / _| (_)  _ __     ___   ___ 
     | | | |  / _ \ | |_  | | | '_ \   / _ \ / __|
     | |_| | |  __/ |  _| | | | | | | |  __/ \__ \
     |____/   \___| |_|   |_| |_| |_|  \___| |___/

*/
#define CRYPTO_COLOUR                        0x33FFBFFF
#define CRYPTO_HEX                          "{33FFBF}"
/*
      _____                                   
     | ____|  _ __    _   _   _ __ ___    ___ 
     |  _|   | '_ \  | | | | | '_ ` _ \  / __|
     | |___  | | | | | |_| | | | | | | | \__ \
     |_____| |_| |_|  \__,_| |_| |_| |_| |___/

*/

enum e_Crypto {

    BitcoinPrice,
    RipplePrice,
    TetherUSPrice,
    LitecoinPrice,
    PolkadotPrice
}

new CryptoPrices[e_Crypto];

enum player_Crypto {

    Float:countBTC,
    Float:countXRP,
    Float:countUSDT,
    Float:countLTC,
    Float:countDOT
}
new PlayerCrypto[MAX_PLAYERS][player_Crypto];

/*
      _   _                   _          
     | | | |   ___     ___   | | __  ___ 
     | |_| |  / _ \   / _ \  | |/ / / __|
     |  _  | | (_) | | (_) | |   <  \__ \
     |_| |_|  \___/   \___/  |_|\_\ |___/

*/
hook OnGameModeInit()
{
    transactions = 
    transactionsBTC = 
    transactionsDOT = 
    transactionsLTC =
    transactionsXRP = 
    transactionsUSDT = 0;

    // Crypto pocetne cene
    CryptoPrices[BitcoinPrice] = 27000;
    CryptoPrices[RipplePrice] = 1;
    CryptoPrices[TetherUSPrice] = 1;
    CryptoPrices[LitecoinPrice] = 93;
    CryptoPrices[PolkadotPrice] = 5;

    if(finishedyet)
    {
        print("crypto/crypto_ogy.script loaded");
    }

    return 1;
}

hook OnPlayerLoaded(playerid)
{
    new q[150];
    mysql_format(SQL, q, sizeof(q), "SELECT * FROM player_crypto WHERE crypto_id = '%d' LIMIT 1", PlayerInfo[playerid][SQLID]);
    mysql_tquery(SQL, q, "LoadPlayerCrypto", "i", playerid);
    return true;
}

hook OnPlayerConnect(playerid)
{
    ResetPlayersCrypto(playerid);

    return (true);
}

/*
      _____                          _     _                       
     |  ___|  _   _   _ __     ___  | |_  (_)   ___    _ __    ___ 
     | |_    | | | | | '_ \   / __| | __| | |  / _ \  | '_ \  / __|
     |  _|   | |_| | | | | | | (__  | |_  | | | (_) | | | | | \__ \
     |_|      \__,_| |_| |_|  \___|  \__| |_|  \___/  |_| |_| |___/

*/
forward LoadPlayerCrypto(playerid);
public LoadPlayerCrypto(playerid)
{
    new rows;
    cache_get_row_count(rows);
    if(!rows)
    {  
        new q[300];
        mysql_format(SQL, q, sizeof(q), 
           "INSERT INTO `player_crypto` (crypto_id, AmountBTC, AmountETH, AmountLTC, AmountDOT, AmountUSDT) \ 
            VALUES('%d', '0', '0', '0', '0', '0')", PlayerInfo[playerid][SQLID]);
        mysql_tquery(SQL, q);
    }
    else
    {
        cache_get_value_name_float(0, "AmountBTC", PlayerCrypto[playerid][countBTC]);
        cache_get_value_name_float(0, "AmountETH", PlayerCrypto[playerid][countXRP]);
        cache_get_value_name_float(0, "AmountLTC", PlayerCrypto[playerid][countLTC]);
        cache_get_value_name_float(0, "AmountUSDT", PlayerCrypto[playerid][countUSDT]);
        cache_get_value_name_float(0, "AmountDOT", PlayerCrypto[playerid][countDOT]);
    }
}

/*
      ____    _                    _          
     / ___|  | |_    ___     ___  | | __  ___ 
     \___ \  | __|  / _ \   / __| | |/ / / __|
      ___) | | |_  | (_) | | (__  |   <  \__ \
     |____/   \__|  \___/   \___| |_|\_\ |___/

*/

stock cryptoString(playerid)
{
    if(transactionsBTC >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][64], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][65], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][66], 16711935);
        }
        else if(ogy == 2)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][64], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][65], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][66], -16776961);
        }
    }
    else if(transactionsUSDT >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][70], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][71], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][72], 16711935);
        }
        else if(ogy == 2)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][70], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][71], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][72], -16776961);
        }
    }
    else if(transactionsDOT >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][73], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][74], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][75], 16711935);
        }
        else if(ogy == 2)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][73], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][74], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][75], -16776961);
        }
    }
    else if(transactionsXRP >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][76], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][77], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][78], 16711935);
        }
        else if(ogy == 2)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][76], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][77], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][78], -16776961);
        }
    }
    else if(transactionsLTC >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][67], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][68], 16711935);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][69], 16711935);
        }
        else if(ogy == 2)
        {
            PlayerTextDrawColour(playerid, BinanceTD[playerid][67], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][68], -16776961);
            PlayerTextDrawColour(playerid, BinanceTD[playerid][69], -16776961);
        }
    }

    new btcprice[30],ltcprice[30],usdtprice[30],dotprice[30],xrpprice[30];

    format(btcprice,sizeof(btcprice),"%d$",CryptoPrices[BitcoinPrice]);
    format(ltcprice,sizeof(ltcprice),"%d$",CryptoPrices[LitecoinPrice]);
    format(usdtprice,sizeof(usdtprice),"%d$",CryptoPrices[TetherUSPrice]);
    format(dotprice,sizeof(dotprice),"%d$",CryptoPrices[PolkadotPrice]);
    format(xrpprice,sizeof(xrpprice),"%d$",CryptoPrices[RipplePrice]);

    PlayerTextDrawSetString(playerid, BinanceTD[playerid][59], btcprice);
    PlayerTextDrawSetString(playerid, BinanceTD[playerid][60], ltcprice);
    PlayerTextDrawSetString(playerid, BinanceTD[playerid][61], usdtprice);
    PlayerTextDrawSetString(playerid, BinanceTD[playerid][62], dotprice);
    PlayerTextDrawSetString(playerid, BinanceTD[playerid][63], xrpprice);

    return (true);
}
stock ResetPlayersCrypto(playerid)
{
    PlayerCrypto[playerid][countBTC] = 
    PlayerCrypto[playerid][countXRP] = 
    PlayerCrypto[playerid][countUSDT] = 
    PlayerCrypto[playerid][countLTC] = 
    PlayerCrypto[playerid][countDOT] = 0.0;

    WatchingCryptoTD[playerid] = false;
}

stock cryptofaqDialog(playerid, id)
{
    new DialogCrypto[1500];
    if(id == 1)
    {
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
        
        strcat( DialogCrypto, ""c_server"Funkcionalnost systema\n" );
        strcat( DialogCrypto, ""c_white"- System funkcionise na osnovu crypto valuta koje 'vladaju svetom'\n");
        strcat( DialogCrypto, ""c_white"- Crypto valute mozete prodavati/kupovati i time dodavati vecu mogucnost u rastu/padu cena istih\n");
        
        strcat( DialogCrypto, ""c_white"- Sa svojim crypto valutama mozete kupovati svakakve stvari u nasem gradu i ostalim okruznim gradovima.\n");
        strcat( DialogCrypto, ""c_white"- Komanda za system je: /crypto.\n");

        strcat( DialogCrypto, ""c_server2"Za bilo koja opsirnija pitanja mozete kontaktirati admine '/report'.\n");

        Dialog_Show( playerid, dialog_none, DIALOG_STYLE_MSGBOX, "Crypto Pomoc", DialogCrypto, "Zatvori", "" );
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
    }
    else if(id == 2)
    {
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
        
        strcat( DialogCrypto, ""c_server"Kako kupiti?\n" );
        strcat( DialogCrypto, ""c_white"- System funkcionise na osnovu crypto valuta koje 'vladaju svetom'\n");
        strcat( DialogCrypto, ""c_white"- Crypto valute mozete prodavati/kupovati i time dodavati vecu mogucnost u rastu/padu cena istih\n");
        
        strcat( DialogCrypto, ""c_white"- Sa svojim crypto valutama mozete kupovati svakakve stvari u nasem gradu i ostalim okruznim gradovima.\n");
        strcat( DialogCrypto, ""c_white"- Komanda za system je: /crypto.\n");

        strcat( DialogCrypto, ""c_server2"Za bilo koja opsirnija pitanja mozete kontaktirati admine '/report'.\n");

        Dialog_Show( playerid, dialog_none, DIALOG_STYLE_MSGBOX, "Crypto Pomoc", DialogCrypto, "Zatvori", "" );
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
    }
    else if(id == 3)
    {
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
    
        strcat( DialogCrypto, ""c_server"Kako  prodati\n" );
        strcat( DialogCrypto, ""c_white"- System funkcionise na osnovu crypto valuta koje 'vladaju svetom'\n");
        strcat( DialogCrypto, ""c_white"- Crypto valute mozete prodavati/kupovati i time dodavati vecu mogucnost u rastu/padu cena istih\n");
        
        strcat( DialogCrypto, ""c_white"- Sa svojim crypto valutama mozete kupovati svakakve stvari u nasem gradu i ostalim okruznim gradovima.\n");
        strcat( DialogCrypto, ""c_white"- Komanda za system je: /crypto.\n");

        strcat( DialogCrypto, ""c_server2"Za bilo koja opsirnija pitanja mozete kontaktirati admine '/report'.\n");

        Dialog_Show( playerid, dialog_none, DIALOG_STYLE_MSGBOX, "Crypto Pomoc", DialogCrypto, "Zatvori", "" );
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
    }
    else if(id == 4)
    {
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
        
        strcat( DialogCrypto, ""c_server"Cemu sluzi?\n" );
        strcat( DialogCrypto, ""c_white"- System funkcionise na osnovu crypto valuta koje 'vladaju svetom'\n");
        strcat( DialogCrypto, ""c_white"- Crypto valute mozete prodavati/kupovati i time dodavati vecu mogucnost u rastu/padu cena istih\n");
        
        strcat( DialogCrypto, ""c_white"- Sa svojim crypto valutama mozete kupovati svakakve stvari u nasem gradu i ostalim okruznim gradovima.\n");
        strcat( DialogCrypto, ""c_white"- Komanda za system je: /crypto.\n");

        strcat( DialogCrypto, ""c_server2"Za bilo koja opsirnija pitanja mozete kontaktirati admine '/report'.\n");

        Dialog_Show( playerid, dialog_none, DIALOG_STYLE_MSGBOX, "Crypto Pomoc", DialogCrypto, "Zatvori", "" );
        strdel( DialogCrypto, 0, sizeof( DialogCrypto ));
    }
    return 1;
}

stock CalculatorCryptoPlayer(const playerid, kolicina, idcrypta)
{
    new Float:dobija;
    switch(idcrypta)
    {
        case 1:
        {
            // btc

            dobija = float(CryptoPrices[BitcoinPrice]);

            printf("%.3f",kolicina / dobija);
            PlayerCrypto[playerid][countBTC] += kolicina / dobija;

            va_SendClientMessage(playerid, x_ltorange, "%.3f",kolicina / dobija);

            transactionsBTC++;
            transactions++;
        }
        case 2:
        {
            // ltc
            dobija = float(CryptoPrices[LitecoinPrice]);

            printf("%.3f",kolicina / dobija);
            PlayerCrypto[playerid][countLTC] += kolicina / dobija;

            va_SendClientMessage(playerid, x_ltorange, "%.3f",kolicina / dobija);

            transactionsLTC++;
            transactions++;
        }
        case 3:
        {
            // dot

            dobija = float(CryptoPrices[PolkadotPrice]);

            printf("%.3f",kolicina / dobija);
            PlayerCrypto[playerid][countDOT] += kolicina / dobija;

            va_SendClientMessage(playerid, x_ltorange, "%.3f",kolicina / dobija);

            transactionsDOT++;
            transactions++;
        }
        case 4:
        {
            // ripple

            dobija = float(CryptoPrices[RipplePrice]);

            printf("%.3f",kolicina / dobija);
            PlayerCrypto[playerid][countXRP] += kolicina / dobija;

            va_SendClientMessage(playerid, x_ltorange, "%.3f",kolicina / dobija);

            transactionsXRP++;
            transactions++;
        }
        case 5:
        {
            // usdt

            dobija = float(CryptoPrices[TetherUSPrice]);

            printf("%.3f",kolicina / dobija);
            PlayerCrypto[playerid][countUSDT] += kolicina / dobija;

            va_SendClientMessage(playerid, x_ltorange, "%.3f",kolicina / dobija);

            transactionsUSDT++;
            transactions++;
        }
    }
    SaveCryptoPlayer(playerid);
    return (true);
}

stock CryptoLookupPlayer(const playerid)
{
    new string[350];
    format(
        string,
        sizeof(string),
        "{D6F481}Kolicina BTC:\t{ffffff}%f\n{D6F481}Kolicina LTC:\t{ffffff}%f\n{D6F481}Kolicina XRP\t{ffffff}%f\n{D6F481}Kolicina DOT\t{ffffff}%f\n{D6F481}Kolicina USDT\t{ffffff}%f\n\n\n\t{D6F481}Made by {121212}Ogy_",
        PlayerCrypto[playerid][countBTC],
        PlayerCrypto[playerid][countLTC],
        PlayerCrypto[playerid][countXRP],
        PlayerCrypto[playerid][countDOT],
        PlayerCrypto[playerid][countUSDT]
    );
    Dialog_Show(playerid, dialog_none, DIALOG_STYLE_MSGBOX, "Vase kriptovalute", string, "Ok", "");
    return (true);
}
/*
      _____   _                                 
     |_   _| (_)  _ __ ___     ___   _ __   ___ 
       | |   | | | '_ ` _ \   / _ \ | '__| / __|
       | |   | | | | | | | | |  __/ | |    \__ \
       |_|   |_| |_| |_| |_|  \___| |_|    |___/

*/

task CryptoMessageTransactions[2700000]()
{
    va_SendClientMessageToAll(CRYPTO_COLOUR, "Crypto Transakcije: {ffffff}U proteklih 45 minuta obavljeno je "CRYPTO_HEX"%d{ffffff} tansakcija na trzistu.",transactions);
    va_SendClientMessageToAll(CRYPTO_COLOUR, "Crypto Transakcije: {ffffff}BTC: %d | USDT: %d | DOT: %d | XRP: %d | LTC: %d",transactionsBTC,transactionsUSDT, transactionsDOT, transactionsXRP, transactionsLTC);
}

task CryptoChangePrice[60000]()
{
    if(transactionsBTC >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            CryptoPrices[BitcoinPrice] += CryptoPrices[BitcoinPrice]+random(4);
        }
        else if(ogy == 2)
        {
            CryptoPrices[BitcoinPrice] -= CryptoPrices[BitcoinPrice]-random(4);
        }
        new Float:BTCPricezz;

        BTCPricezz = float(CryptoPrices[BitcoinPrice]);

        va_SendClientMessageToAll(CRYPTO_COLOUR, "Bitcoin Obavestenje: {ffffff}BTC: Trenutna cena: %.4f | Transkacija: %d",BTCPricezz,transactionsBTC);
    }
    else if(transactionsUSDT >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            CryptoPrices[TetherUSPrice] += CryptoPrices[TetherUSPrice]+random(1);
        }
        else if(ogy == 2)
        {
            CryptoPrices[TetherUSPrice] -= CryptoPrices[TetherUSPrice]-random(1);
        }
        new Float:USDTPricezz;

        USDTPricezz = float(CryptoPrices[TetherUSPrice]);
        va_SendClientMessageToAll(CRYPTO_COLOUR, "Tether Obavestenje: {ffffff}USDT: Trenutna cena: %.3f | Transkacija: %d",USDTPricezz,transactionsUSDT);
    }
    else if(transactionsDOT >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            CryptoPrices[PolkadotPrice] += CryptoPrices[PolkadotPrice]+random(1);
        }
        else if(ogy == 2)
        {
            CryptoPrices[PolkadotPrice] -= CryptoPrices[PolkadotPrice]-random(1);
        }
        new Float:DOTPricezz;

        DOTPricezz = float(CryptoPrices[PolkadotPrice]);
        va_SendClientMessageToAll(CRYPTO_COLOUR, "Polkadot Obavestenje: {ffffff}DOT: Trenutna cena: %.3f | Transkacija: %d",DOTPricezz,transactionsDOT);
    }
    else if(transactionsXRP >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            CryptoPrices[RipplePrice] += CryptoPrices[RipplePrice]+random(1);
        }
        else if(ogy == 2)
        {
            CryptoPrices[RipplePrice] -= CryptoPrices[RipplePrice]-random(1);
        }
        new Float:XRPPricezz;

        XRPPricezz = float(CryptoPrices[RipplePrice]);
        va_SendClientMessageToAll(CRYPTO_COLOUR, "Ripple Obavestenje: {ffffff}XRP: Trenutna cena: %.3f | Transkacija: %d",XRPPricezz,transactionsXRP);
    }
    else if(transactionsLTC >= 1)
    {
        new ogy = random(2);
        if(ogy == 1)
        {
            CryptoPrices[LitecoinPrice] += CryptoPrices[LitecoinPrice]+random(4);
        }
        else if(ogy == 2)
        {
            CryptoPrices[LitecoinPrice] -= CryptoPrices[LitecoinPrice]-random(4);
        }
        new Float:LTCPricezz;

        LTCPricezz = float(CryptoPrices[LitecoinPrice]);
        va_SendClientMessageToAll(CRYPTO_COLOUR, "Litecoin Obavestenje: {ffffff}LTC: Trenutna cena: %.3f | Transkacija: %d",LTCPricezz,transactionsLTC);
    }
    return 1;
}
/*
       ____                                                       _       
      / ___|   ___    _ __ ___    _ __ ___     __ _   _ __     __| |  ___ 
     | |      / _ \  | '_ ` _ \  | '_ ` _ \   / _` | | '_ \   / _` | / __|
     | |___  | (_) | | | | | | | | | | | | | | (_| | | | | | | (_| | \__ \
      \____|  \___/  |_| |_| |_| |_| |_| |_|  \__,_| |_| |_|  \__,_| |___/

*/
YCMD:crypto(const playerid, params[], help)
{
    if(help)
    {
        SendClientMessage(playerid, CRYPTO_COLOUR, "[Crypto]: Ova komanda vam dozvoljava da kupujete/prodajete crypto valute.");
        return 1;
    }
    if(WatchingCryptoTD[playerid])
    {
        BuildCryptoTextDraws(playerid, false);
    }
    else if(!WatchingCryptoTD[playerid])
    {
        BuildCryptoTextDraws(playerid, true);
    }
    return 1;
}
YCMD:mojcrypto(const playerid, params[], help)
{
    if(help)
    {
        SendClientMessage(playerid, CRYPTO_COLOUR, "[Crypto]: Ova komanda vam dozvoljava da pogledate svoje kriptovalute.");
        return 1;
    }
    CryptoLookupPlayer(playerid);
    return (true);
}
/*
      ____    _           _                       
     |  _ \  (_)   __ _  | |   ___     __ _   ___ 
     | | | | | |  / _` | | |  / _ \   / _` | / __|
     | |_| | | | | (_| | | | | (_) | | (_| | \__ \
     |____/  |_|  \__,_| |_|  \___/   \__, | |___/
                                      |___/       
*/


Dialog:dialog_kupibtc(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {
        new kolicina;
        if(sscanf(inputtext, "i", kolicina))
            return Dialog_Show(playerid, dialog_kupibtc, DIALOG_STYLE_INPUT, "Kupovina BTC", "Upisite za koliko novca zelite da kupite ovu kriptovalutu:\n\n** CENA BITCOINA VARIRA PROVERITE PRE KUPOVINE.", "Dalje", "Izlaz");


        if(kolicina > GetPlayerMoney(playerid))
            return SendClientMessage(playerid, CRYPTO_COLOUR, "> Nemate toliko novca.");

        if(kolicina < 1000 || kolicina > CryptoPrices[BitcoinPrice])
            return va_SendClientMessage(playerid, CRYPTO_COLOUR, "> Kolicina moze biti od 1000$ pa do %d$.",CryptoPrices[BitcoinPrice]);


        CalculatorCryptoPlayer(playerid, kolicina, 1);
    }
    return (true);
}
Dialog:dialog_kupiltc(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {
        new kolicina;
        if(sscanf(inputtext, "i", kolicina))
            return Dialog_Show(playerid, dialog_kupiltc, DIALOG_STYLE_INPUT, "Kupovina LTC", "Upisite za koliko novca zelite da kupite ovu kriptovalutu:\n\n** CENA BITCOINA VARIRA PROVERITE PRE KUPOVINE.", "Dalje", "Izlaz");


        if(kolicina > GetPlayerMoney(playerid))
            return SendClientMessage(playerid, CRYPTO_COLOUR, "> Nemate toliko novca.");

        if(kolicina < 1000 || kolicina > CryptoPrices[LitecoinPrice])
            return va_SendClientMessage(playerid, CRYPTO_COLOUR, "> Kolicina moze biti od 1000$ pa do %d$.",CryptoPrices[LitecoinPrice]);
        

        CalculatorCryptoPlayer(playerid, kolicina, 2);
    }
    return (true);
}
Dialog:dialog_kupidot(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {
        new kolicina;
        if(sscanf(inputtext, "i", kolicina))
            return Dialog_Show(playerid, dialog_kupidot, DIALOG_STYLE_INPUT, "Kupovina DOT", "Upisite za koliko novca zelite da kupite ovu kriptovalutu:\n\n** CENA BITCOINA VARIRA PROVERITE PRE KUPOVINE.", "Dalje", "Izlaz");


        if(kolicina > GetPlayerMoney(playerid))
            return SendClientMessage(playerid, CRYPTO_COLOUR, "> Nemate toliko novca.");

        if(kolicina < 1000 || kolicina > CryptoPrices[PolkadotPrice])
            return va_SendClientMessage(playerid, CRYPTO_COLOUR, "> Kolicina moze biti od 1000$ pa do %d$.",CryptoPrices[PolkadotPrice]);
        

        CalculatorCryptoPlayer(playerid, kolicina, 3);
    }
    return (true);
}
Dialog:dialog_kupixrp(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {
        new kolicina;
        if(sscanf(inputtext, "i", kolicina))
            return Dialog_Show(playerid, dialog_kupixrp, DIALOG_STYLE_INPUT, "Kupovina XRP", "Upisite za koliko novca zelite da kupite ovu kriptovalutu:\n\n** CENA BITCOINA VARIRA PROVERITE PRE KUPOVINE.", "Dalje", "Izlaz");


        if(kolicina > GetPlayerMoney(playerid))
            return SendClientMessage(playerid, CRYPTO_COLOUR, "> Nemate toliko novca.");

        if(kolicina < 1000 || kolicina > CryptoPrices[RipplePrice])
            return va_SendClientMessage(playerid, CRYPTO_COLOUR, "> Kolicina moze biti od 1000$ pa do %d$.",CryptoPrices[RipplePrice]);
        

        CalculatorCryptoPlayer(playerid, kolicina, 4);
    }
    return (true);
}
Dialog:dialog_kupiusdt(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {
        new kolicina;
        if(sscanf(inputtext, "i", kolicina))
            return Dialog_Show(playerid, dialog_kupiusdt, DIALOG_STYLE_INPUT, "Kupovina USDT", "Upisite za koliko novca zelite da kupite ovu kriptovalutu:\n\n** CENA BITCOINA VARIRA PROVERITE PRE KUPOVINE.", "Dalje", "Izlaz");


        if(kolicina > GetPlayerMoney(playerid))
            return SendClientMessage(playerid, CRYPTO_COLOUR, "> Nemate toliko novca.");

        if(kolicina < 1000 || kolicina > CryptoPrices[TetherUSPrice])
            return va_SendClientMessage(playerid, CRYPTO_COLOUR, "> Kolicina moze biti od 1000$ pa do %d$.",CryptoPrices[TetherUSPrice]);
        

        CalculatorCryptoPlayer(playerid, kolicina, 5);
    }
    return (true);
}

Dialog:dialog_prodajbtc(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {

    }
    return (true);
}
Dialog:dialog_prodajusdt(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {

    }
    return (true);
}
Dialog:dialog_prodajxrp(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {

    }
    return (true);
}
Dialog:dialog_prodajltc(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {

    }
    return (true);
}
Dialog:dialog_prodajdot(const playerid, response, listitem, string:inputtext[])
{
    if(!response)
        return 1;

    if(response)
    {

    }
    return (true);
}